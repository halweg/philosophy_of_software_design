# pd of software design

## 02复杂性本质

### 定义

- 复杂性是与软件系统的结构有关的任何东西，它使系统难于理解和修改
- 表现形式

	- 难以理解的代码
	- 一个小的改进需要很多努力
	- 修改一处BUG，引入另外一处bug

### 症状

- 变更需要无限放大

	- 一个看似简单的变更需要在许多不同的地方修改代码

- 认知负荷

	- 开发人员为了完成一项任务需要知道多少
	- 虽然有些框架用了短短几行代码来编写应用，
但是要弄清这几行代码是什么却很困难，
有时多行代码实际上更简单，
因为他减少了认知负荷

- 未知的未知

	- 必须修改哪些代码才能完成任务，或者开发人员必须获得哪些信息才能成功地执行任务，这些都是不明显的。
	- 在复杂性的三种表现形式中，未知的未知是最糟糕的。

### 复杂度的成因

- 依赖性
依赖会导致变化放大和高认知负荷。

	- 当不能独立地理解和修改给定的代码段时，就会存在依赖项；代码在某种程度上与其他代码相关，如果给定代码发生更改，则必须考虑和/或修改其他代码。
	- 一个web所有页面都使用了bannerBg,这个class一变，全部页面都会变

		- 新的Web站点用一个更简单、更明显的依赖项代替了一个不明显、难于管理的依赖项。（无class）

	- 方法签名在实现和调用者之间创建了一个依赖关系，如果参数列表变动，调用者势必也要修改
	- 我们故意将依赖关系作为软件设计过程的一部分，每次编写新类时，都要围绕该类的API创建依赖項，
但是软件设计的目标之一是减少依赖数量的使依赖简单，明显

- 模糊性（晦涩）
晦涩创造了未知的未知，也增加了认知负荷。

	- 当重要的信息不明显时，就会发生模糊。一个简单的例子是一个变量名，它是如此的通用，以至于它没有携带太多有用的信息(例如，时间)。
	- 或者，一个变量的文档可能没有指定它的单位，所以找到它的惟一方法是扫描代码，查找变量使用的位置。
	- 查找变量使用的位置。晦涩常常与依赖项相关，而依赖项的存在并不明显。
	- 例如，如果向系统添加了一个新的错误状态，可能需要向一个包含每个状态的字符串消息的表添加一个条目，但是对于查看状态声明的程序员来说，消息表的存在可能并不明显。
	- 不一致性也是造成不透明性的一个主要原因：如果同一个变量名用于两个不同的目的，那么开发人员就无法清楚地知道特定变量的作用
	- 在许多情况下，含糊不清是因为文档不充分；第13章讨论这个主题。然而，晦涩也是一个设计问题。如果一个系统有一个清晰而明显的设计，那么它将需要更少的文档。需要大量的文档通常是设计不太正确的一个危险信号。减少模糊的最佳方法是简化系统设计。
	- 子主题 7

### 递增

- 复杂性不是由单个灾难性错误造成的，而是由许多小问题积累而成。 

	- 单个依赖项或晦涩本身不太可能对软件系统的可维护性产生重大影响。复杂性的产生是因为成百上千的小的依赖和模糊随着时间的推移而累积。

- 复杂性的递增性使其难以控制。

	-  很容易让自己相信，您当前的更改所引入的一点复杂性并不是什么大问题。但是，如果每个开发人员对每个更改都采用这种方法，那么复杂性会迅速增加。
	- 为了减缓复杂性的增长，您必须采用“零容忍”的哲学

## 03编程的战术和战略

### 战术的编程

- 战术编程的问题在于它是短视的
- 告诉自己，如果可以让当前的任务更快完成，增加一点复杂性或者引入一两个小的封装是可以的，
这就是系统变得复杂的原因。
- 战术旋风。战术旋风是一个多产的程序员谁泵出的代码比别人快得多，但工作在一个完全战术的方式。

### 战略。

- 战略规划需要一种投资心态。 
- 一些投资将是积极的。

	- 花一点额外的时间为每个新类找到一个简单的设计是值得的;与其实施第一个出现在脑海中的想法，不如尝试几个替代的设计，选择最干净的一个。试着想象一些系统在未来可能需要改变的方式，并确保你的设计是简单的。编写好的文档是主动投资的另一个例子。

- 其他投资将是被动的。

	- 当你发现一个设计问题时，不要忽视它或修补它;花一点额外的时间来修复它。如果您有策略地进行编程，您将不断地对系统设计进行小的改进。

###  投资多少?

- 一笔巨大的前期投资，比如试图设计整个系统，是不会有效的。这就是瀑布法，我们知道它行不通。
- 随着您对系统的经验的积累，理想的设计往往会零零碎碎地出现。
- 最好的方法是在连续的基础上进行大量的小额投资。
- 好的设计不是免费的。它必须是你不断投资的东西，这样小问题就不会积累成大问题。 幸运的是，好的设计最终会收回成本，而且比你想象的要快。


## 04深度封装模块

### 模块化设计

- 软件系统被分解成一系列相对独立的模块，理想是每个模块完全独立，开发人员无需了解自己负责范围之外的模块，但这是无法实现的
在这个世界上，一个系统的复杂性就是其最坏模块的复杂性。

	- 模块必须通过调用彼此的函数或方法来协同工作。因此，模块之间必须相互了解。
模块之间会有依赖关系：如果一个模块改变了，其他模块可能需要改变来匹配。
依赖关系可以有很多形式，而且可能非常微妙。模块化设计的目标是最小化模块之间的依赖关系。

- 为了管理依赖关系，我们将每个模块分为两部分：接口和实现。
接口（只描述做什么）

	- 其中接口包含了在不同模块中工作的开发人员为了使用给定模块必须知道的所有内容。通常，接口描述模块做什么，而不是如何做。实现由实现接口承诺的代码组成。在特定模块中工作的开发人员必须了解该模块的接口和实现，以及给定模块调用的任何其他模块的接口。开发人员不应该需要了解模块的实现而不是他或她所工作的模块。
	- 考虑一个实现平衡树的模块。模块可能包含复杂的代码，用于确保树保持平衡。但是，这种复杂性对模块的用户是不可见的。用户可以看到一个相对简单的接口，用于调用在树中插入、删除和获取节点的操作。要调用插入操作，调用方只需提供新节点的键和值;遍历树和分割节点的机制在接口中不可见。

- 对于本书而言，模块是具有接口和实现的任何代码单元。

	- 面向对象编程语言中的每个类都是一个模块。
	- 类中的方法，或者非面向对象语言中的函数，也可以被看作模块：
每个模块都有一个接口和一个实现，可以对它们应用模块化设计技术。
	- 更高层次的子系统和服务也是模块；它们的接口可能采用不同的形式，比如内核调用或 HTTP 请求。

- 最好的模块是那些接口比实现简单得多的模块。

	- 这样的模块有 两个优点：首先，简单的接口最小化了模块对系统其余部分的影响。 
	- 其次，如果一个模块以不改变其接口的方式进行了修改，那么其他模块都不会受到修改的影响。
	- 如果一个模块的接口比它的实现简单得多，那么模块的许多方面都可以在不影响其他模块的情况下进行更改

### 什么是接口?

- 模块的接口包含两种信息：正式的

	- 接口的形式化部分在代码中明确指定，其中一些可以由编程语言检查其正确性。例如，方法的正式接口是其签名，其中包括参数的名称和类型、返回值的类型以及方法抛出的异常信息。
	- 大多数编程语言都确保方法的每次调用都提供正确的参数数量和类型，以匹配其签名。
	- 类的正式接口由其所有公共方法的签名，以及任何公共变量的名称和类型组成。

- 模块的接口包含两种信息：非正式的
它们没有以编程语言可以理解或执行的方式指定

	- 接口的非正式部分包括其高级行为，例如函数删除由其参数之一命名的文件。
	- 如果在类的使用上有约束(可能一个方法必须在另一个方法之前调用)，这些也是类接口的一部分。
通常，如果开发人员需要了解特定的信息才能使用模块，那么这些信息就是模块接口的一部分。
	- 接口的非正式方面只能用注释来描述，而且编程语言不能确保描述是完整的或准确的。
	- 对于大多数接口来说，非正式方面比正式方面更大、更复杂。
	- 一个明确指定的接口的好处之一是，它准确地指出了开发人员为了使用相关模块而需要知道的内容。这有助于消除“未知的未知”问题

### 抽象

抽象这个术语与模块化设计的思想密切相关。抽象是一个实体的简化视图，它忽略了不重要的细节。抽象是有用的，因为它使我们更容易思考和操作复杂的事物。

- 在模块化编程中，每个模块都提供了接口的抽象形式,该接口提供了模块功能的简化视图；从模块抽象的角度来看，实现的细节并不重要，因此在接口中省略了它们。
- 抽象中省略的不重要的细节越多越好。

	- "不重要"
可能在两方面出错。

		- 首先，它可以包含一些并不重要的细节，当这种情况发生时，它使抽象变得比必要的更复杂，这增加了使用抽象的开发人员的认知负担。
		- 第二个错误是抽象忽略了真正重要的细节。

 这导致了模糊性：只关注抽象的开发人员将无法获得正确使用抽象所需的所有信息。忽略重要细节的抽象是错误的抽象：它可能看起来很简单，但实际上并不简单。设计抽象的关键是理解什么是重要的，并寻找最小化重要信息量的设计。

- 以文件系统为例。

	- 文件系统提供的抽象忽略了许多细节，比如选择存储设备上哪些块用于给定文件中的数据的机制。这些细节对于文件系统的用户并不重要(只要系统提供足够的性能)。但是，文件系统实现的某些细节对用户来说很重要。大多数文件系统将数据缓存在主存中，为了提高性能，它们可能会延迟向存储设备写入新数据。有些应用程序(如数据库)需要确切地知道何时将数据写入存储器，这样它们就可以确保在系统崩溃后数据仍将被保留。因此，将数据刷新到辅助存储的规则必须在文件系统的接口中可见。

- 我们不仅依赖抽象来管理编程中的复杂性，而且在我们的日常生活中也无处不在。
微波炉，汽车。。。。。。

### 深度模块

- 最好的模块是那些功能强大但接口简单的模块。
deep 模块

	- 最好的模块是深度封装的：
它们在一个简单的接口背后隐藏了很多功能。
深度模块是一个很好的抽象，因为用户只能看到它内部复杂性的一小部分
	- 最好的模块是深度的：它们允许通过一个简单的接口访问大量的功能。

浅层模块具有相对复杂的接口，但是没有太多的功能：它没有隐藏太多的复杂性。

- 模块深度是考虑成本与收益的一种方式。

	- 模块提供的好处是它的功能，模块的成本(就系统复杂性而言)是它的接口。
	- 模块的接口表示模块对系统其余部分施加的复杂性：接口越小、越简单，它所引入的复杂性就越低。 
	- 最好的模块是那些收益最大、成本最低的模块。接口是好的，但更多或更大的接口不一定更好!

- Unix 操作系统及其后代(如 Linux)提供的文件 I/O 机制是一个漂亮的深度接口示例

	- I/O 只有 5 个基本的系统调用，签名比较简单：
open(path, flag, mode_t_permissions)
read(int fd, void* buffer, size_t count);
write(int fd, const void* buffer, size_t count);
t lseek(int fd, off_t offset, int referencePosition);
int close(int fd);

		- open

			- open 系统调用采用/a/b/c 这样的层次文件名，并返回一个整数文件描述符，用于引用打开的文件
			- Open 的其他参数提供可选的信息，比如文件是否被打开用于读写，如果没有现有文件，是否应该创建新文件，如果创建了新文件，是否应该创建该文件的访问权限。

		- r/w

			- 读写系统调用在应用程序的内存和文件的缓冲区之间传输信息;

		- close

			- ;关闭对文件的访问。

		- lseek

			- 大多数文件是按顺序访问的，所以这是默认的;但是，可以通过调用 lseek 系统调用来更改当前访问位置来实现随机访问。

	- Unix I/O 接口的现代实现需要数十万行代码，这些代码解决了以下复杂问题：


		- 如何在磁盘上表示文件以允许有效访问?

		- 如何存储目录，如何处理层次路径名以查找它们所引用的文件?

		- 如何实施权限，使一个用户不能修改或删除另一个用户的文件?

		- 如何实现文件访问?例如，如何在中断处理程序和后台代码之间划分功能，以及这两个元素如何安全通信?

		- 当存在对多个文件的并发访问时，使用什么调度策略?

		- 如何将最近访问的文件数据缓存在内存中以减少磁盘访问的次数?

		- 如何将各种不同的辅助存储设备(如磁盘和闪存驱动器)合并到单个文件系统中?


	- 所有这些问题以及更多的问题都由 Unix 文件系统实现来处理；它们对于调用系统调用的程序员是不可见的。多年来，Unix I/O 接口的实现已经发生了根本的变化，但是五个基本的内核调用并没有改变。


- 深度模块的另一个例子是 Go 或 Java 等语言中的垃圾收集器

	- 该模块完全没有接口；它在幕后无形地回收未使用的内存。
	- 向系统中添加垃圾收集实际上会缩小整个接口，因为它消除了释放对象的接口。
	- 垃圾收集器的实现相当复杂，但是这种复杂性对使用该语言的程序员来说是隐藏的。
	- Unix I/O 和垃圾收集器等深度模块提供了强大的抽象，因为它们易于使用，但它们隐藏了重要的实现复杂性

### 浅层模块

- 与它提供的功能相比，浅层模块的接口相对复杂。

	- 例如，实现链表的类是浅层次的。操作一个链表并不需要太多代码(插入或删除一个元素只需要几行代码)，所以链表抽象并没有隐藏很多细节。
	- 链表接口的复杂性几乎与其实现的复杂性一样大。浅层类有时是不可避免的，但是它们在管理复杂性方面没有提供太多帮助。
	- 例如 ：addNullValueForAttribute （String attribute）
实现 ： data.put(null)
该方法不提供任何抽象，因为它的所有功能都是通过接口可见的。

- 从管理复杂性的角度来看，这种方法使事情变得更糟，而不是更好。
- 危险信号：浅层模块的接口相对于它提供的功能来说是复杂的。浅层模块在与复杂性的斗争中帮助不大，因为它们提供的好处(不需要了解它们内部如何工作)被学习和使用它们的接口的成本所抵消。小模块往往是浅层的。

### 类拆分

- 不幸的是，深度的价值在今天没有得到广泛的重视。

	- 编程的传统智慧是类应该是小的，而不是深的。
	- 学生们经常被教导，在班级设计中最重要的事情是把大班级分成小班级。对于方法也经常给出相同的建议:“任何超过 N 行的方法都应该划分为多个方法”(N 可以低至 10)。这种方法会产生大量的浅层类和方法，从而增加了整个系统的复杂性。

- “类应该小”方法的极端是一种我称之为类拆分的综合征，它源于“类是好的，所以更多的类更好”的错误观点。

	- 在遭受类拆分困扰的系统中，鼓励开发人员最小化每个新类中的功能数量：如果您想要更多的功能，那么就引入更多的类。
	- 类拆分可能会产生单独简单的类，但是它增加了整个系统的复杂性。
	- 小类不会提供太多的功能，所以必须有很多类，每个类都有自己的接口。
	- 这些接口的积累在系统级造成了巨大的复杂性。由于每个类都需要样板文件，所以小类也会导致冗长的编程风格。

### 示例:Java 和 Unix I/O

- 。如果一个接口有很多特性，但是大多数开发人员只需要知道其中的几个，那么这个接口的有效复杂度就是常用特性的复杂度。
- 子主题 2

### 结论

- 通过将模块的接口与其实现分离，我们可以向系统的其他部分隐藏实现的复杂性。模块的用户只需要理解其接口提供的抽象。
- 在设计类和其他模块时，最重要的问题是使它们更深入，这样它们就有了公共用例的简单接口，同时还提供了重要的功能。
- 存在这样的语言，主要是在研究领域，在那里一个方法或功能的整体行为可以用规范语言来正式描述。可以自动检查规范，以确保它与实现匹配。一个有趣的问题是，这样的正式规范是否可以取代接口的非正式部分。我目前的观点是，对于开发人员来说，用英语描述的接口可能比用正式规范语言编写的接口更直观、更容易理解。

## 05信息隐藏

### 隐藏信息

-  David Parnas 描述。基本思想是每个模块应该封装一些知识，这些知识表示设计决策。该知识嵌入到模块的实现中，但不出现在其接口中，因此其他模块无法看到它
- 模块中隐藏的信息通常包含如何实现某种机制的细节。以下是一些可能隐藏在模块中的信息示

<---例

	- 如何在 b 树中存储信息，以及如何有效地访问它。
如何识别文件中每个逻辑块对应的物理磁盘块。
如何实现 TCP 网络协议。
如何调度多核处理器上的线程。
如何解析 JSON 文档。
	- 隐藏信息包括与该机制相关的数据结构和算法。它还可以包括低级的细节，如页面的大小，还可以包括更抽象的高级概念，如大多数文件都很小的假设。

- 信息隐藏在两个方面降低了复杂性。首先，它将接口简化为模块。

	- 接口反映了模块功能的更简单、更抽象的视图，并隐藏了细节;这减少了使用该模块的开发人员的认知负担。

例如，使用 B-tree 类的开发人员不必担心树中节点的扇出(fan out)，也不必担心如何保持树的平衡。
	- 其次，信息隐藏使系统更容易演化。

		- 如果隐藏了一段信息，那么在包含该信息的模块之外就不存在对该信息的依赖
		- 因此与该信息相关的设计更改将只影响一个模块。
		- 例如，如果 TCP 协议发生了变化(例如，为了引入一种新的拥塞控制机制)，协议的实现就必须进行修改，但是在使用 TCP 发送和接收数据的高级代码中不需要进行任何修改

- 在设计新模块时，您应该仔细考虑哪些信息可以隐藏在该模块中。

	- 注意：通过将变量和方法声明为私有来隐藏它们与信息隐藏是不同的。

		- 私有元素可以帮助信息隐藏，因为它们使其不可能从类外部直接访问。

但是，关于私有项的信息仍然可以通过公共方法(如 getter 和 setter 方法)公开。

当这种情况发生时，变量的性质和用法就像公开变量一样公开。

- 信息隐藏的最佳形式是将信息完全隐藏在模块中，这样模块的用户就不会看到这些信息。

	- 然而，部分信息隐藏也有其价值。
例如，如果某个特定的特性或信息片段只由少数类用户需要，并且通过单独的方法访问它，
	- 因此在最常见的用例中不可见，那么该信息大部分是隐藏的。这样的信息创建的依赖关系要比每个类用户可见的信息少

### 信息泄露

- 信息隐藏的反面是信息泄露。

	- 当一个设计决策反映在多个模块中时，就会发生信息泄漏。这在模块之间创建了一个依赖关系：

		- 对设计决策的任何更改都需要对所有相关模块进行更改。
		- 如果一段信息反映在模块的接口中，那么根据定义，它已经被泄露了；
因此，更简单的接口往往与更好的信息隐藏相关
		- 然而，即使信息没有出现在模块的接口中，它也可能被泄露。

			- 假设两个类都知道某种特定的文件格式(可能一个类读取这种格式的文件，另一个类写入这些文件)。
			- 即使这两个类都没有在其接口中公开该信息，它们也都依赖于文件格式：如果格式更改，则需要修改这两个类。
			- 像这样的后门泄漏比通过接口泄漏更有害，因为它并不明显

- 信息泄漏是软件设计中最重要的危险信号之一

	-  作为一个软件设计师，你能学到的最好的技能之一就是对信息泄露的高度敏感性。
	- 合并类

		- 如果您在类之间遇到信息泄漏，请自问“我如何才能重新组织这些类，使这些特定的知识只影响一个类？”如果受影响的类相对较小，并且与泄漏的信息紧密相关，那么将它们合并到一个类中是有意义的。

	- 加一层新类

		- 另一种可能的方法是从所有受影响的类中提取信息，并创建一个只封装这些信息的新类。
		- 但是，这种方法只有在您能够找到一个从细节中抽象出来的简单接口时才有效;如果新类通过其接口公开了大部分知识，那么它就不会提供太多的价值(您只是用通过接口的泄漏替换了后门泄漏)

- 危险信号：信息泄漏 

### 时间分解

- 陷阱

	- 在时间分解中，系统的结构与操作发生的时间顺序相对应。
	- 很容易陷入时间分解的陷阱，因为在编写代码时，必须考虑操作发生的顺序
	- 在应用程序的生命周期中，大多数设计决策都会在几个不同的时间出现；因此，时间分解常常导致信息泄漏

- 应对

	- 在设计模块时，要关注执行每个任务所需的知识，而不是任务发生的顺序。
	- 顺序通常很重要，所以它将反映在应用程序的某个地方。但是，它不应该反映在模块结构中，除非该结构与信息隐藏一致(可能不同的阶段使用完全不同的信息)

###  示例：学生版HTTP 服务器

- 示例：类太多

	- 学生常犯的错误：把代码分成大量的浅层类
	- 一个团队使用两个不同的类来接收http请求，
一个类将网络请求读入字符串,
第二个类解析该字符串

这是一个时间分解的例子：需要先读取，再解析
	- 因为这些类共享了如此多的信息，所以最好将它们合并到一个处理请求读取和解析的类中。这提供了更好的信息隐藏，因为它将所有关于请求格式的知识隔离在一个类中，而且它还为调用者提供了更简单的接口(只需调用一个方法)
	- 这个例子说明了软件设计中的一个普遍主题：信息隐藏通常可以通过使类稍微大一点来改进。
	- 这样做的一个原因是将与特定功能相关的所有代码(比如解析 HTTP 请求)放在一起，这样得到的类就包含了与该功能相关的所有内容。
	- 增加类大小的第二个原因是提高接口的级别;例如，不是为一个计算的三个步骤中的每个步骤使用单独的方法，而是使用单个方法来执行整个计算。这可以导致一个更简单的接口。
	- 两个优点都适用于前一段的示例:组合这些类将所有与解析 HTTP 请求相关的代码放在一起，并将两个外部可见的方法替换为一个。合并的类比原来的类更深。
	- 大类的概念可能太过宽泛(例如对于整个应用程序只有一个类)。第 9 章将讨论在什么情况下将代码分成多个更小的类是有意义的。

- 示例:HTTP 参数处理

	- public String getParameter(String name)
接口优秀于
public Map<String, String> getParams()

- 示例:HTTP 响应中的默认值

	- 默认值说明了这样一个原则，即接口的设计应该尽可能使普通情况变得简单。
	- 它们也是部分信息隐藏的一个例子:在正常情况下，调用者不需要知道缺省项的存在。
	- 在调用者需要覆盖默认值的少数情况下，它必须知道这个值，并且可以调用一个特殊的方法来修改它
	- 只要可能，Class应该“做正确的事情”，而不是被显式地询问。默认值就是一个例子。

Java I/O 示例以一种消极的方式说明了这一点。文件 I/O 中的缓冲是普遍需要的，因此没有人需要显式地请求它，甚至不需要知道它的存在;I/O 类应该做正确的事情并自动提供它。最好的功能是那些你甚至不知道它们存在的功能

###  隐藏在类中的信息

- 但是信息隐藏也可以应用于系统中的其他级别，比如类。尝试在类中设计私有方法，以便每个方法都封装一些信息或功能，并对类的其他部分隐藏这些信息或功能。
- 此外，尽量减少使用每个实例变量的数量。
- 有些变量可能需要在整个类中广泛地访问，但其他变量可能只需要在少数地方访问；

如果可以减少使用变量的位置数量，就可以消除类中的依赖性并降低其复杂性

### 不要过度隐藏

- 信息隐藏只有在被隐藏的信息在其模块之外不需要时才有意义。如果需要模块之外的信息，则不能隐藏它。
- 假设某个模块的性能受到某些配置参数的影响，并且模块的不同使用需要不同的参数设置。在这种情况下，在模块的接口中公开参数是很重要的，
- 作为一名软件设计师，您的目标应该是最小化模块外所需的信息量；例如，如果模块可以自动调整其配置，这比公开配置参数要好
- 重要的是要识别模块外部需要哪些信息，并确保它是公开的。

### 结论

- 信息隐藏与深度模块密切相关。如果一个模块隐藏了很多信息，就会增加模块提供的功能，同时也减少了它的接口。这使得模块更深入。相反，如果一个模块没有隐藏很多信息，那么要么它没有太多的功能，要么它有一个复杂的接口；不管怎样，这个模块都是浅层的。
- 在将系统分解成模块时，尽量不受运行时操作发生顺序的影响；这将引导您进入时间分解的路径，这将导致信息泄漏和浅模块。

相反，请考虑执行应用程序任务所需的不同知识片段，并设计每个模块来封装这些知识片段中的一个或几个。这将产生一个干净和简单的设计与深模块。


## 06更深的通用模块

### 起因

- 我们很难预测明天需求的变化，所以在实现新模块时，有两种不同的流派：
1.只关注今天的需求，他日需要更多的需求时，我们根据计划来重构

2.让新模块适度的通用一些

### 使类具有一定的通用性

- 观点：
使用更通用一些 的类来实现新模块。
1.模块的功能应该反映您当前的需求，但是它的接口不应该反应具体需求

2.不要忘乎所以，不要构建一些特别通用的东西，因为它很难满足您当前的需求

###  坏的示例：为编辑器存储文本

- 现在有一个基本的文本 Text类，
这个类的API有：

	- load接口
	- read接口
	- update接口 
	- store接口

- 一些团队在text类中创建了一个方法来支持这些特性

	- void backspace(Cursor cursor)
	- void delete(Cursor cursor)
	- viud deleteSelection(Selection selection)

- 上述三个接口的缺点

	- 这种方法在用户界面和文本类之间造成了信息泄漏。与用户界面相关的抽象，如选择或退格键，反映在文本类中
	- ;这增加了开发人员处理文本类的认知负荷。每一个新的用户界面操作都需要在text类中定义一个新方法，因此处理用户界面的开发人员可能最终也要处理text类
	- 。类设计的目标之一是允许独立地开发每个类，但是专门化的方法将用户界面和文本类绑定在一起。
	- 学生们可能认为如果text类的方法对应于用户可见的特性，那么实现用户界面会更容易。然而，在现实中，这种专门化对用户界面代码几乎没有什么好处，而且它为用户界面或文本类的开发人员带来了很高的认知负荷。text类以大量的浅层方法结束，每个浅层方法只适合一个用户界面操作
	- 许多方法(如delete)只在一个地方调用。因此，开发用户界面的开发人员必须了解文本类的大量方法。

		- 学生们可能认为如果text类的方法对应于用户可见的特性，那么实现用户界面会更容易。然而，在现实中，这种专门化对用户界面代码几乎没有什么好处，而且它为用户界面或文本类的开发人员带来了很高的认知负荷。text类以大量的浅层方法结束，每个浅层方法只适合一个用户界面操作

###  编辑器好的示例：更通用的API

- void insert(Position position, String newText);
void delete(Position start, Position end);

	- 优点

		- 1.这个API只根据文本特性来定义, 不用反映将用它实现的高级操作

- Position changePosition(Position position, int numChars);


	- 这个API还使用了一个更通用的类型Position而不是游标，它反映了一个特定的用户界面。text类还应该提供一些通用的工具来处理文本中的位置
	- 此方法返回一个新位置，该位置距离给定位置有一定数量的字符。如果numChars参数为正，则新位置在文件中的时间晚于位置;如果数字是负数，则新位置在位置之前。该方法在必要时自动跳转到下一行或上一行。使用这些方法，可以用以下代码实现delete键(假设游标变量保存当前游标位置)：

- text.delete(cursor, text.changePosition(cursor, 1));
text.delete(text.changePosition(cursor, -1), cursor);


### 通用性使得信息隐藏效果更好

- 通用方法在文本和用户接口类之间提供了更清晰的分离，从而实现更好的信息隐藏
- 文本类不需要知道用户界面的细节，比如如何处理退格键，这些细节封装在user interface类中。
可以添加新的用户界面特性，而无需在text类中创建新的支持函数。
- 通用接口还减少了认知负担：
开发人员只需要学习一些简单的方法，这些方法可以用于各种目的
- 原始版本中的错误

	- backspace方法是一个错误的抽象

		- backspance这个api的目的是隐藏掉删除哪些字符的信息，但是原始界面模块确实需要知道他删除了哪些字符
		- 用户界面的开发人员可能会阅读backspace方法来确定这个方法的准确行为
		- 把这个方法放到text类中，只会让用户界面开发人员更难获得他们所需要的信息
		- 软件设计最重要的元素之一就是：
决定谁需要知道什么，什么时候需要知道。
		- 当细节很重要时，最好让他们透明和明显
		- 比如backspace操作的修改和实现，将这些信息隐藏在接口后面，只会造成不透明性。

### 
如何识别一个干净通用的类：
问三个问题

- 什么是最简单的接口？
可以满足我当前的所有需求？

	- 如果您减少了API中的方法数量，而没有减少它的整体功能，
那么您可能正在创建更通用的方法
	- 特殊用途的文本API至少有三种删除文本的方法:backspace、delete和deleteSelection。

更通用的API只有一个用于删除文本的方法，
却这能支持这三个功能
	- 只有在每个方法的API保持简单的情况下，减少方法的数量才有意义;如果为了减少方法的数量，您不得不引入许多额外的参数，那么您可能并没有真正地简化事情。

- 在多少种情况下会使用这个方法？

	- 如果一个方法是为一个特定的用途而设计的，比如backspace方法，那么这就是一个危险信号

因为它可能太特殊了。看看是否可以将几个专用方法替换为一个通用方法。

- 这个API容易实现我当前的需求吗？

	- 这个问题可以用于判断，你是不是在把API搞得更通用这条路上，用力过猛了
	- 如果您必须编写大量额外的代码来使用一个类来满足当前的需要，那么接口没有提供正确的功能，就是一个危险的信号。
	- 如，text类的一种方法是围绕单字符操作进行设计:insert插入单个字符，delete删除单个字符。这个API既简单又通用。但是，对于文本编辑器来说，它并不特别容易使用:高级代码将包含许多循环来插入或删除字符范围。
	- 对于大型操作，单字符方法的效率也很低。因此，文本类最好内置对字符范围的操作的支持。

### 总结

- 与专用接口相比，通用接口有许多优点

	- 他包含更少的方法
	- 他们还提供了类之间更清晰的分离
	- 特殊用途的接口往往会泄露类之间的信息

- 让模块具有一定的通用性，是降低系统复杂性的不二法门

*XMind - Trial Version*